# Hacky one line lookahead
PeekLine := function(stream)
  return stream.curline;
end;

GetLine := function(stream)
  local ret;
  ret := stream.curline;
  stream.curline := ReadLine(stream.ins);
  return ret;
end;

ReadEntry := function(stream)
  local name, content, line, sline;
  
  line := GetLine(stream);
  NormalizeWhitespace(line);
  if Position(line, ':') = fail then
    Error("Not a valid entry");
  fi;

  sline := SplitString(line, ":");
  name := NormalizedWhitespace(sline[1]);
  content := [ NormalizedWhitespace(Concatenation(sline{ [2..Length(sline)] })) ];
 
  repeat
    line := PeekLine(stream);
    if line <> fail and line[1] = ' ' then
      Add(content, NormalizedWhitespace(line));
      GetLine(stream);
    fi;
  until line = fail or line[1] <> ' ';
  return rec( name := name, content := content );
end;

ReadRecord := function(stream)
  local entry, record;

  record := rec();
  repeat
    entry := ReadEntry(stream);
    record.(entry.name) := entry.content;
  until PeekLine(stream) = fail or IsEmpty(NormalizedWhitespace(PeekLine(stream)));   
  # Read the empty line
  GetLine(stream);
  return record;
end;

ReadPariDesc := function(filename)
  local desc, res;

  res := [];

  desc := rec( ins := InputTextFile(filename) );
  desc.curline := ReadLine(desc.ins);

  while not IsEndOfStream(desc.ins) do
    Add(res, ReadRecord(desc));
  od;
  return res;
end;

ParameterList := function(basename, count)
    return JoinStringsWithSeparator(
                                     List([1..count], x -> Concatenation(basename,String(x))), ", ");
end;

GenerateGlueFunction := function(func)
    local i, name, argt, argc, res, conversions;

    name := func.("C-Name")[1];
    argt := func.Prototype[1];
    argc := Length(argt);

    conversions := Concatenation(List([1..argc],
    i -> StringFormatted("    GEN ga{} = PARI_DAT_GEN(a{});\n", i, i)));

    res := StringFormatted(
"""static Obj FuncPARI_{}(Obj self, {})
{{
{}
    return NewPARIGEN({}({}));
}}""",
    name,
    ParameterList("Obj a", argc),
    conversions,
    name,
    ParameterList("ga", argc) );
    return res;
end;

GenerateGlueGVar := function(func)
  local res;
  return StringFormatted( "GVAR_FUNC(PARI_{},{},\"{}\")"
                        , func.("C-Name")[1]
                        , Length(func.Prototype[1])
                        , ParameterList("g", Length(func.Prototype[1]) ) );
end;

GenerateGlueCode := function(desc, outs)
  local func, functions, gvars;

  exported := Set([]);
  functions := [];
  gvars := [];

  for func in desc do
    if IsBound(func.("C-Name")) and (func.("C-Name")[1] in exported) then
      Print("not exporting function ", func.("C-Name")[1], " because it loccurs more than once in pari.desc\n");
      continue;
    fi;
    if IsBound(func.Prototype) then
      if func.Prototype[1] in ["G", "GG", "GGG"] and 
          (IsBound(func.Class) and func.Class[1] in [ "basic" ]) and
          (IsBound(func.Section) and (not (func.Section[1] in ["programming/internals"]))) then
          Add(functions, GenerateGlueFunction(func));
          Add(gvars, GenerateGlueGVar(func));
          AddSet(exported, func.("C-Name")[1]);
      else
          Print( "not exporting ", func.Function, " because of ",
                 "unsupported prototype ", func.Prototype[1], "\n");
      fi;
    else
      Print( "not exporting ", func.Function,
             " because it does not have a prototype\n");
    fi;
  od;

  PrintTo(outs, "// This file is automatically generated from\n");
  PrintTo(outs, "// pari.desc. Do not edit it manually\n\n");
  PrintTo(outs, "#include <pari/pari.h>\n");
#  PrintTo(outs, "#include <pari/paridecl.h>\n");
  PrintTo(outs, "#include \"src/compiled.h\"\n");
  PrintTo(outs, "#include \"PARIInterface.h\"\n\n");

  for func in functions do
      PrintTo(outs, func);
      PrintTo(outs, "\n\n");
  od;
  PrintTo(outs, "StructGVarFunc GVarPariFuncs [] = {\n");
  for func in gvars do
      PrintTo(outs, func);
      PrintTo(outs, ",\n");
  od;
  PrintTo(outs, "{ 0 }\n };");
end;

desc := ReadPariDesc("../extern/install/share/pari/pari.desc");
outs := OutputTextFile("pariglue.c", false);
GenerateGlueCode(desc, outs);
